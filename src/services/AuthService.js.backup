const DatabaseService = require('./DatabaseService');
const PortalDataTransferService = require('./PortalDataTransferService');

class AuthService {
  constructor() {
    this.dbService = new DatabaseService();
    this.portalService = new PortalDataTransferService();
    this.currentUser = null;
    this.currentSession = null;
    // Note: Clerk is handled in the renderer process only
  }

  // Process authentication data from renderer process
  async processAuthentication(userData) {
    try {
      console.log('🔐 Processing authentication:', {
        userId: userData.id,
        email: userData.email,
        name: userData.name
      });

      // Validate required fields
      if (!userData.email && !userData.id) {
        throw new Error('Missing required authentication data: email or user ID');
      }

      // Create or update user in database
      const userId = await this.dbService.createOrUpdateUser(userData);
      
      // Start new app session
      const deviceInfo = this.getDeviceInfo();
      const appVersion = this.getAppVersion();
      const sessionId = await this.dbService.startAppSession(userId, deviceInfo, appVersion);

      // Store current user and session
      this.currentUser = { 
        ...userData, 
        id: userId,
        app_session_id: sessionId,
        sync_status: 'active',
        last_sync: new Date().toISOString()
      };
      this.currentSession = { 
        id: sessionId, 
        userId, 
        startTime: new Date(),
        authMethod: userData.provider || 'clerk_sdk'
      };

      // Log authentication event
      await this.dbService.logUsage(
        userId,
        'authentication',
        'login',
        null,
        JSON.stringify({
          provider: userData.provider,
          sessionId: sessionId,
          deviceInfo: deviceInfo,
          timestamp: new Date().toISOString()
        }),
        null,
        null
      );

      console.log('✅ Authentication processing completed:', {
        userId,
        sessionId,
        email: userData.email
      });

      return {
        user: this.currentUser,
        session: this.currentSession
      };
    } catch (error) {
      console.error('❌ Authentication processing failed:', error);
      throw error;
    }
  }

  // Sign out - handles cleanup in main process
  async signOut() {
    try {
      // Clear local state and session
      if (this.currentSession) {
        await this.logActivity('authentication', 'logout');
        await this.dbService.endAppSession(this.currentSession.id);
      }

      this.currentUser = null;
      this.currentSession = null;

      console.log('✅ Sign-out completed');
    } catch (error) {
      console.error('Failed to sign out:', error);
      // Fallback: clear local state
      this.currentUser = null;
      this.currentSession = null;
    }
  }

  // Request password reset
  async requestPasswordReset(email) {
    if (!this.clerk) {
      throw new Error('Clerk not initialized');
    }

    try {
      // Use Clerk's built-in password reset functionality
      await this.clerk.client.signIn.create({
        strategy: 'reset_password_email_code',
        identifier: email
      });
      
      console.log('Password reset email sent to:', email);
      return { success: true, message: 'Password reset email sent. Please check your inbox.' };
    } catch (error) {
      console.error('Failed to request password reset:', error);
      throw error;
    }
  }

  // Reset password with code
  async resetPassword(email, code, newPassword) {
    if (!this.clerk) {
      throw new Error('Clerk not initialized');
    }

    try {
      // Use Clerk's built-in password reset functionality
      const signIn = await this.clerk.client.signIn.create({
        strategy: 'reset_password_email_code',
        identifier: email,
        code: code,
        password: newPassword
      });
      
      // If successful, sign in the user
      if (signIn.status === 'complete') {
        await this.clerk.setActive({ session: signIn.createdSessionId });
        console.log('Password reset successful for:', email);
        return { success: true, message: 'Password reset successful. You are now signed in.' };
      } else {
        throw new Error('Password reset failed. Please try again.');
      }
    } catch (error) {
      console.error('Failed to reset password:', error);
      throw error;
    }
  }

  // Enable multi-factor authentication
  async enableMFA() {
    if (!this.clerk) {
      throw new Error('Clerk not initialized');
    }

    if (!this.clerk.user) {
      throw new Error('User not authenticated');
    }

    try {
      // Check if MFA is already enabled
      const user = this.clerk.user;
      if (user.totpEnabled) {
        console.log('MFA already enabled for user');
        return { success: true, message: 'Multi-factor authentication is already enabled.' };
      }

      // Prepare MFA setup
      const mfaSetup = await this.clerk.client.signIn.prepareFirstFactor({
        strategy: 'totp',
        totp: {
          issuer: 'Hintify SnapAssist AI',
          user: user.primaryEmailAddress?.emailAddress || user.username || user.id
        }
      });

      console.log('MFA setup prepared:', mfaSetup);
      return { 
        success: true, 
        message: 'MFA setup initiated. Please scan the QR code with your authenticator app.',
        totpSecret: mfaSetup.totpSecret,
        qrCode: mfaSetup.qrCode
      };
    } catch (error) {
      console.error('Failed to enable MFA:', error);
      throw error;
    }
  }

  // Verify MFA setup
  async verifyMFASetup(code) {
    if (!this.clerk) {
      throw new Error('Clerk not initialized');
    }

    try {
      // Verify the TOTP code
      const verification = await this.clerk.client.signIn.attemptFirstFactor({
        strategy: 'totp',
        code: code
      });

      if (verification.status === 'complete') {
        await this.clerk.setActive({ session: verification.createdSessionId });
        console.log('MFA setup verified successfully');
        return { success: true, message: 'Multi-factor authentication enabled successfully.' };
      } else {
        throw new Error('MFA verification failed. Please try again.');
      }
    } catch (error) {
      console.error('Failed to verify MFA setup:', error);
      throw error;
    }
  }

  // Disable MFA
  async disableMFA() {
    if (!this.clerk) {
      throw new Error('Clerk not initialized');
    }

    if (!this.clerk.user) {
      throw new Error('User not authenticated');
    }

    try {
      // Disable MFA for the user
      await this.clerk.user.disableTotp();
      console.log('MFA disabled for user');
      return { success: true, message: 'Multi-factor authentication disabled successfully.' };
    } catch (error) {
      console.error('Failed to disable MFA:', error);
      throw error;
    }
  }

  // Legacy method for backward compatibility
  async processAuthentication(authData) {
    // This method is kept for any remaining legacy calls
    // but new authentication should go through Clerk
    console.warn('⚠️ Legacy processAuthentication called - consider using Clerk authentication');
    
    if (authData.provider === 'clerk' || authData.source === 'clerk') {
      // If this is Clerk data, handle it properly
      return await this.handleClerkSignIn(authData, { id: authData.sessionId });
    }
    
    throw new Error('Legacy authentication not supported - please use Clerk');
  }

  // Get current authenticated user
  getCurrentUser() {
    return this.currentUser;
  }

  // Get current session
  getCurrentSession() {
    return this.currentSession;
  }

  // Check if user is authenticated
  isAuthenticated() {
    return !!this.currentUser;
  }

  // Log user activity
  async logActivity(featureName, action, details = null) {
    if (!this.currentUser || !this.currentSession) {
      console.warn('Cannot log activity: no authenticated user or session');
      return;
    }

    try {
      await this.dbService.logUsage(
        this.currentUser.id,
        this.currentSession.id,
        featureName,
        action,
        details
      );
    } catch (error) {
      console.error('Failed to log activity:', error);
    }
  }

  // Save question and answer
  async saveQuestionAnswer(questionText, answerText, questionType = 'text', aiProvider = 'gemini', aiModel = 'gemini-2.0-flash', imageData = null, metadata = null, processingTime = null) {
    if (!this.currentUser || !this.currentSession) {
      throw new Error('User not authenticated');
    }

    try {
      // Save question
      const questionId = await this.dbService.saveQuestion(
        this.currentUser.id,
        this.currentSession.id,
        questionText,
        questionType,
        imageData,
        metadata
      );

      // Save answer
      const answerId = await this.dbService.saveAnswer(
        questionId,
        this.currentUser.id,
        answerText,
        aiProvider,
        aiModel,
        null, // confidence score
        processingTime
      );

      // Log the Q&A activity
      await this.logActivity('question_answer', 'completed', {
        questionId,
        answerId,
        questionType,
        aiProvider,
        aiModel
      });

      console.log('✅ Question and answer saved successfully:', { questionId, answerId });

      // Automatically trigger data transfer to Portal after each Q&A
      // This ensures the Portal always has the latest user data
      setTimeout(async () => {
        try {
          console.log('🚀 Auto-transferring latest data to Portal...');
          await this.transferDataToPortal();
        } catch (error) {
          console.log('⚠️ Auto-transfer to Portal failed (will retry later):', error.message);
        }
      }, 2000); // Wait 2 seconds to ensure data is fully saved

      return { questionId, answerId };

    } catch (error) {
      console.error('Failed to save question/answer:', error);
      throw error;
    }
  }

  // Sync account data after transfer
  async syncAccountData() {
    if (!this.currentUser) {
      throw new Error('User not authenticated');
    }

    try {
      console.log('🔄 Starting account data synchronization...');
      
      // Log sync activity
      await this.logActivity('account_sync', 'initiated', {
        transferSource: this.currentSession?.transferSource,
        authMethod: this.currentSession?.authMethod
      });

      // Update user sync status
      this.currentUser.sync_status = 'syncing';
      this.currentUser.last_sync = new Date().toISOString();

      // Perform comprehensive data sync
      const syncResult = await this.portalService.transferUserDataToPortal(
        this.currentUser.id,
        'account_sync'
      );

      // Update sync status based on result
      this.currentUser.sync_status = syncResult.success ? 'active' : 'error';
      this.currentUser.last_sync = new Date().toISOString();

      // Log completion
      await this.logActivity('account_sync', 'completed', {
        success: syncResult.success,
        syncStatus: this.currentUser.sync_status
      });

      console.log('✅ Account data synchronization completed:', {
        success: syncResult.success,
        syncStatus: this.currentUser.sync_status
      });

      return syncResult;

    } catch (error) {
      // Update sync status to error
      if (this.currentUser) {
        this.currentUser.sync_status = 'error';
        this.currentUser.last_sync = new Date().toISOString();
      }

      // Log failure
      await this.logActivity('account_sync', 'failed', {
        error: error.message
      });
      
      throw error;
    }
  }

  // Get account sync status
  getAccountSyncStatus() {
    return {
      status: this.currentUser?.sync_status || 'unknown',
      lastSync: this.currentUser?.last_sync,
      transferSource: this.currentSession?.transferSource,
      authMethod: this.currentSession?.authMethod
    };
  }
  async transferDataToPortal() {
    if (!this.currentUser) {
      throw new Error('User not authenticated');
    }

    try {
      // Log data transfer activity
      await this.logActivity('data_transfer', 'initiated');

      const result = await this.portalService.transferUserDataToPortal(this.currentUser.id);

      // Log completion
      await this.logActivity('data_transfer', 'completed', {
        transferId: result.transferId,
        success: result.success
      });

      return result;

    } catch (error) {
      // Log failure
      await this.logActivity('data_transfer', 'failed', {
        error: error.message
      });
      
      throw error;
    }
  }

  // Export user data
  async exportUserData(format = 'json') {
    if (!this.currentUser) {
      throw new Error('User not authenticated');
    }

    try {
      await this.logActivity('data_export', 'initiated', { format });

      const result = await this.portalService.exportUserData(this.currentUser.id, format);

      await this.logActivity('data_export', 'completed', { format });

      return result;

    } catch (error) {
      await this.logActivity('data_export', 'failed', {
        format,
        error: error.message
      });
      
      throw error;
    }
  }

  // Get user history
  async getUserHistory(limit = 50) {
    if (!this.currentUser) {
      throw new Error('User not authenticated');
    }

    return await this.dbService.getUserHistory(this.currentUser.id, limit);
  }

  // Sign out user
  async signOut() {
    try {
      if (this.currentSession) {
        // Log signout activity
        await this.logActivity('authentication', 'logout');

        // End current session
        await this.dbService.endAppSession(this.currentSession.id);
      }

      // Clear current user and session
      this.currentUser = null;
      this.currentSession = null;

      console.log('🚪 User signed out successfully');

    } catch (error) {
      console.error('Failed to sign out properly:', error);
      // Clear local state anyway
      this.currentUser = null;
      this.currentSession = null;
    }
  }

  // Get device information
  getDeviceInfo() {
    const os = require('os');
    
    // Check if we're running in Electron context
    let appVersion = '1.0.0';
    try {
      const { app } = require('electron');
      appVersion = app.getVersion();
    } catch (error) {
      // Not running in Electron context (e.g., testing)
      appVersion = '1.0.0-test';
    }

    return {
      platform: process.platform,
      arch: process.arch,
      osType: os.type(),
      osRelease: os.release(),
      appVersion: appVersion,
      electronVersion: process.versions.electron || 'n/a',
      nodeVersion: process.versions.node
    };
  }

  // Get app version
  getAppVersion() {
    try {
      const { app } = require('electron');
      return app.getVersion();
    } catch (error) {
      // Not running in Electron context
      return '1.0.0-test';
    }
  }

  // Initialize authentication from stored data
  async initializeFromStorage(store) {
    try {
      // Wait for Clerk to be initialized
      if (!this.clerk) {
        console.log('🔄 Waiting for Clerk to initialize...');
        // Wait up to 5 seconds for Clerk to initialize
        for (let i = 0; i < 50; i++) {
          if (this.clerk) break;
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }

      if (!this.clerk) {
        console.warn('⚠️ Clerk not available, cannot restore authentication');
        return false;
      }

      // Check if user is already signed in with Clerk
      if (this.clerk.user && this.clerk.session) {
        console.log('🔄 Restoring Clerk authentication from active session');
        await this.handleClerkSignIn(this.clerk.user, this.clerk.session);
        return true;
      }

      // Fallback: check stored authentication (legacy)
      const isAuthenticated = store.get('user_authenticated', false);
      const userInfo = store.get('user_info', null);

      if (isAuthenticated && userInfo && userInfo.email) {
        console.log('🔄 Found legacy authentication, attempting to restore...');
        
        // Get user from database
        const user = await this.dbService.getUserByEmail(userInfo.email);
        
        if (user) {
          this.currentUser = user;

          // Check for active session or create new one
          let activeSession = await this.dbService.getActiveSession(user.id);
          
          if (!activeSession) {
            // Start new session
            const deviceInfo = this.getDeviceInfo();
            const appVersion = this.getAppVersion();
            const sessionId = await this.dbService.startAppSession(user.id, deviceInfo, appVersion);
            activeSession = { id: sessionId, user_id: user.id };
          }

          this.currentSession = {
            id: activeSession.id,
            userId: user.id,
            startTime: activeSession.session_start || new Date()
          };

          console.log('🔄 Legacy authentication restored:', {
            userId: user.id,
            sessionId: activeSession.id,
            email: user.email
          });

          return true;
        }
      }

      return false;

    } catch (error) {
      console.error('Failed to initialize authentication from storage:', error);
      return false;
    }
  }
}

module.exports = AuthService;